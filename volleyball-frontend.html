<!DOCTYPE html>
<html>

<head>
	<title>Volleyball Scorebug 5200x1080</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,300..900;1,300..900&display=swap" rel="stylesheet">

	<style>
		/* ----- Main ----- */
		body {
			margin: 0;
			padding: 0;
			background: transparent;
			font-family: "Rubik", serif;
			font-style: italic;
			font-weight: 600;
			color: white;
		}

		#scoreboard {
			position: relative;
			top: 300px;
			left: 1600px;
			width: 1920px;
			height: calc(1920px * (3014 / 7743));
			background-image: url('PC Volleyball Scoreboard v3.png');
			background-size: contain;
			background-repeat: no-repeat;
			z-index: 2;
		}

		/* ----- Stats ----- */
		.stats-animation {
			position: absolute;
			top: 380px;
			width: 1575px;
			height: 661px;
			background: rgba(179, 85, 85, 0.8);
			/* background: rgba(179, 85, 85, 1); */
			transform-origin: bottom;
			transform: skew(-10deg) translateX(100%);
			display: none;
			z-index: 1;
		}

		#home-stats-animation {
			/* left: 1800px; */
			left: 1825px;
		}

		#guest-stats-animation {
			/* left: -1548px; */
			left: -1573px;
		}

		.stats-text {
			position: absolute;
			width: 100%;
			text-align: center;
			top: 2%;
			transform: skew(10deg);
			font-size: 89px;
			color: white;
		}

		/* ----- Score ----- */
		.number-ticker {
			overflow: hidden;
			height: 1.042em;
			background: transparent;
			position: absolute;
			font-size: 149px;
			font-weight: 700;
			top: 17.3%;
			font-family: "Rubik", serif;
			font-style: italic;
		}

		.digit {
			float: left;
			line-height: 1;
			transition: margin-top 3s ease;
			font-variant-numeric: tabular-nums;
		}

		#home-score {
			left: 53.5%;
		}

		#guest-score {
			right: 54%;
		}

		/* ----- Timeouts ----- */
		.timeouts {
			position: absolute;
			transform: skew(-10deg) translateX(100%);
			height: 28px;
			width: 221px;
		}

		.timeout-available {
			background-color: white;
			border: 15px solid white;
		}

		.timeout-used {
			background-color: transparent;
			border: 15px dashed #c1c6c880;
		}

		.timeout-1-top {
			top: 18.5%;
		}

		.timeout-2-bottom {
			top: 29%;
		}

		#home-timeout1 {
			left: 71.15%;
		}

		#guest-timeout1 {
			left: -9.85%;
		}

		#home-timeout2 {
			left: 70.5%;
		}

		#guest-timeout2 {
			left: -10.5%;
		}

		.timeouts span {
			transition: opacity 0.3s ease-in-out;
		}

		.timeouts span.blink {
			animation: blinkTimeout 0.5s ease-in-out 6;
		}

		@keyframes blinkTimeout {
			0%, 100% { opacity: 1; }
			50% { opacity: 0; }
		}

		#timeout-animation {
			position: absolute;
			top: 109px;
			left: 1667.7px;
			width: 1881px;
			height: 140px;
			background: rgba(239, 172, 29);
			transform-origin: bottom;
			transform: skew(-10deg) translateY(100%);
			display: none;
			z-index: 1;
		}

		#timeout-text {
			position: absolute;
			width: 100%;
			text-align: center;
			top: 50%;
			transform: translateY(-50%) skew(10deg);
			/* Counter-skew the text */
			font-size: 122px;
			color: white;
		}

		/* ----- Fouls ----- */
		.sets-won {
			position: absolute;
			top: 46%;
			font-size: 130px;
			font-weight: 700;
		}

		#home-sets-won {
			left: 70%;
		}

		#guest-sets-won {
			left: 24%;
		}

		@keyframes blink {
			0%,
			100% {
				opacity: 1;
			}

			50% {
				opacity: 0;
			}
		}

		.blink {
			animation: blink 0.5s ease-in-out 6;
		}

		/* ----- Clocks ----- */
		.clock {
			position: absolute;
		}

		#period {
			top: 44%;
			left: 35%;
			font-size: 130px;
			font-weight: 700;
			text-align: center;
			width: 550px;
		}
	</style>
</head>

<body>
	<!----- HTML  ----->
	<div id="timeout-animation">
		<div id="timeout-text"></div>
	</div>
	<div class="stats-animation" id="home-stats-animation">
		<div class="stats-text" id="home-stats-text">Home Team Stats</div>
	</div>
	<div class="stats-animation" id="guest-stats-animation">
		<div class="stats-text" id="guest-stats-text">Guest Team Stats</div>
	</div>
	<div id="scoreboard" class="scoreboard">
		<div class="clock" id="period">1st SET</div>

		<div class="score number-ticker" id="home-score" data-value="0"></div>
		<div class="timeouts timeout-1-top timeout-used" id="home-timeout1"></div>
		<div class="timeouts timeout-2-bottom timeout-available" id="home-timeout2"></div>
		<div class="sets-won number-ticker" id="home-sets-won" data-value="0"></div>

		<div class="score number-ticker" id="guest-score" data-value="0"></div>
		<div class="timeouts timeout-1-top timeout-available" id="guest-timeout1"></div>
		<div class="timeouts timeout-2-bottom timeout-available" id="guest-timeout2"></div>
		<div class="sets-won number-ticker" id="guest-sets-won" data-value="0"></div>
	</div>

	<!----- JavaScript  ----->
	<script>
		const timeoutAnimation = document.getElementById('timeout-animation');
		const timeoutText = document.getElementById('timeout-text');
		const homeStatsAnimation = document.getElementById('home-stats-animation');
		const guestStatsAnimation = document.getElementById('guest-stats-animation');

		let currentTimeoutAnimation = null;
		let timeoutAnimationState = 'hidden'; // Can be 'hidden', 'showing', or 'hiding'

		const defaultDigitNode = document.createElement('div');
		defaultDigitNode.classList.add('digit');
		for (let i = 0; i < 10; i++) {
			defaultDigitNode.innerHTML += i + '<br>';
		}

		// Initialize tickers
		const homeScoreTicker = createNumberTicker(document.getElementById('home-score'));
		const guestScoreTicker = createNumberTicker(document.getElementById('guest-score'));
		const homeSetTicker = createNumberTicker(document.getElementById('home-sets-won'));
		const guestSetTicker = createNumberTicker(document.getElementById('guest-sets-won'));

		let lastHomeScore = 0;
		let lastGuestScore = 0;
		let lastHomeTimeouts = 0;
		let lastGuestTimeouts = 0;
		let lastHomeSets = 0;
		let lastGuestSets = 0;

		// Stats animation state and tracking
		let currentHomeStatsAnimation = null;
		let currentGuestStatsAnimation = null;
		/* let homeStatsAnimationState = 'hidden';
		let guestStatsAnimationState = 'hidden'; */
		let lastHomeStats = null;
		let lastGuestStats = null;
		let homeStatsTimeout = null;
		let guestStatsTimeout = null;

		function updateTeamTimeouts(team, newCount) {
			const lastCount = team === 'home' ? lastHomeTimeouts : lastGuestTimeouts;
			const timeout1 = document.getElementById(`${team}-timeout1`);
			const timeout2 = document.getElementById(`${team}-timeout2`);

			// Set the correct state for both timeouts
			if (newCount === 2) {
				timeout1.classList.add('timeout-available');
				timeout2.classList.add('timeout-available');

				timeout1.classList.remove('timeout-used');
				timeout2.classList.remove('timeout-used');
			} else if (newCount === 1) {
				timeout1.classList.add('timeout-used');
				timeout2.classList.add('timeout-available');

				timeout1.classList.remove('timeout-available');
				timeout2.classList.remove('timeout-used');
			} else {
				timeout1.classList.add('timeout-used');
				timeout2.classList.add('timeout-used');

				timeout1.classList.remove('timeout-available');
				timeout2.classList.remove('timeout-available');
			}

			// Timeout taken animation (only animate if decrement)
			if (newCount < lastCount) {
				if (lastCount === 2 && newCount === 1) {
					// First timeout: top first
					blinkAndUse(timeout1);
				} else if (lastCount === 1 && newCount === 0) {
					// Second timeout: bottom
					blinkAndUse(timeout2);
				}
			}

			if (team === 'home') {
				lastHomeTimeouts = newCount;
			} else {
				lastGuestTimeouts = newCount;
			}
		}

		function blinkAndUse(element) {
			element.classList.add('blink');
			setTimeout(() => {
				element.classList.remove('blink');
				element.classList.remove('timeout-available');
				element.classList.add('timeout-used');
			}, 3000); // after blink finishes
		}

		function updateStatsAnimation(statsElement, statsText, duration, isHome) {
			// If no stats or stats haven't changed, do nothing
			const currentStats = statsText.trim();
			const lastStats = isHome ? lastHomeStats : lastGuestStats;

			//console.log("currentStats: " + currentStats, " lastStats: " + lastStats, " duration: " + duration);
			if (currentStats === lastStats) return;

			// Clear any existing timeouts
			if (isHome && homeStatsTimeout) {
				clearTimeout(homeStatsTimeout);
				homeStatsTimeout = null;
			} else if (!isHome && guestStatsTimeout) {
				clearTimeout(guestStatsTimeout);
				guestStatsTimeout = null;
			}

			// Update the tracked last stats
			if (isHome) {
				lastHomeStats = currentStats;
			} else {
				lastGuestStats = currentStats;
			}

			// If stats are empty, hide the element
			if (!currentStats) {
				const slideOutAnimation = statsElement.animate([
					{ clipPath: isHome ? 'inset(0% 0% 0% 0%)' : 'inset(0% 0% 0% 0%)' },
					{ clipPath: isHome ? 'inset(0% 100% 0% 0%)' : 'inset(0% 0% 0% 100%)' }
				], {
					duration: 1000,
					easing: 'ease-in',
					fill: 'forwards'
				});
				slideOutAnimation.onfinish = () => {
					statsElement.style.display = 'none';
				};
				return;
			}

			// Cancel any existing animation for this stats element
			if (isHome && currentHomeStatsAnimation) {
				currentHomeStatsAnimation.cancel();
			}
			if (!isHome && currentGuestStatsAnimation) {
				currentGuestStatsAnimation.cancel();
			}

			// Show the stats animation
			statsElement.style.display = 'block';

			// Animate sliding in
			const slideInAnimation = statsElement.animate([
				{ clipPath: isHome ? 'inset(0% 100% 0% 0%)' : 'inset(0% 0% 0% 100%)' },
				{ clipPath: isHome ? 'inset(0% 0% 0% 0%)' : 'inset(0% 0% 0% 0%)' }
			], {
				duration: 1000,
				easing: 'ease-out',
				fill: 'forwards'
			});

			// Store the current animation
			if (isHome) {
				currentHomeStatsAnimation = slideInAnimation;
			} else {
				currentGuestStatsAnimation = slideInAnimation;
			}

			// If duration is set (not infinite), schedule the hide animation
			if (duration > 0) {
				const hideTimeout = setTimeout(() => {
					const slideOutAnimation = statsElement.animate([
						{ clipPath: isHome ? 'inset(0% 0% 0% 0%)' : 'inset(0% 0% 0% 0%)' },
						{ clipPath: isHome ? 'inset(0% 100% 0% 0%)' : 'inset(0% 0% 0% 100%)' }
					], {
						duration: 1000,
						easing: 'ease-in',
						fill: 'forwards'
					});

					slideOutAnimation.onfinish = () => {
						statsElement.style.display = 'none';
					};

					// Store the current animation
					if (isHome) {
						currentHomeStatsAnimation = slideOutAnimation;
					} else {
						currentGuestStatsAnimation = slideOutAnimation;
					}
				}, duration * 1000);

				// Store the timeout
				if (isHome) {
					homeStatsTimeout = hideTimeout;
				} else {
					guestStatsTimeout = hideTimeout;
				}
			}
		}

		function updateTimeoutAnimation(timeoutClock) {
			const [minutes, seconds] = timeoutClock.split(':').map(parseFloat);
			const time = minutes * 60 + seconds;

			if (!time || time <= 0) {
				if (timeoutAnimationState === 'showing') {
					timeoutAnimation.style.display = 'block';
					if (currentTimeoutAnimation) {
						currentTimeoutAnimation.cancel();
					}

					currentTimeoutAnimation = timeoutAnimation.animate([
						{ clipPath: 'inset(0% 0% 0% 0%)' },
						{ clipPath: 'inset(100% 0% 0% 0%)' }
					], {
						duration: 2000,
						easing: 'ease-out',
						fill: 'forwards'
					});

					timeoutAnimationState = 'hiding';
					currentTimeoutAnimation.onfinish = () => {
						timeoutAnimation.style.display = 'none';
						timeoutAnimationState = 'hidden';
					};
				}
				return;
			}

			timeoutText.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;

			if (timeoutAnimationState !== 'showing') {
				timeoutAnimation.style.display = 'block';
				if (currentTimeoutAnimation) {
					currentTimeoutAnimation.cancel();
				}

				currentTimeoutAnimation = timeoutAnimation.animate([
					{ clipPath: 'inset(100% 0% 0% 0%)' },
					{ clipPath: 'inset(0% 0% 0% 0%)' }
				], {
					duration: 2000,
					easing: 'ease-out',
					fill: 'forwards'
				});

				timeoutAnimationState = 'showing';
			}
		}

		function createTimeoutDisplay(elementId) {
			const element = document.getElementById(elementId);
			element.innerHTML = ''; // Clears any existing content, otherwise we just append a LOT more...oops
			let currentTimeouts = [];
			let isAnimating = false;

			function updateTimeouts(newCount) {
				newCount = parseInt(newCount) || 0;
				const previousCount = currentTimeouts.length;

				if (newCount === previousCount) return;

				// Clear existing timeouts first
				element.innerHTML = '';
				currentTimeouts = [];

				// Create all new timeout indicators
				for (let i = 0; i < newCount; i++) {
					const timeoutSpan = document.createElement('span');
					timeoutSpan.textContent = 'I ';
					element.appendChild(timeoutSpan);
					currentTimeouts.push(timeoutSpan);
				}

				// If we're removing timeouts and not currently animating
				if (newCount < previousCount && !isAnimating) {
					for (let i = newCount; i < previousCount; i++) {
						const timeoutSpan = document.createElement('span');
						timeoutSpan.textContent = 'I ';
						timeoutSpan.classList.add('blink');
						element.appendChild(timeoutSpan);

						isAnimating = true;
						setTimeout(() => {
							timeoutSpan.remove();
							isAnimating = false;
						}, 3000);
					}
				}
			}

			return { updateTimeouts };
		}

		function createNumberTicker(element) {
			let currentValue = 0;
			let digits = [];

			function generateDigits(amount) {
				for (let i = 0; i < amount; i++) {
					const digitNode = defaultDigitNode.cloneNode(true);
					digitNode.isNew = true; // Mark as new
					element.appendChild(digitNode);
					digits.unshift(digitNode); // Add to start of array
				}
			}

			function removeExtraDigits(targetLength) {
				while (digits.length > targetLength) {
					const digitToRemove = digits.shift(); // Remove from start of array
					element.removeChild(digitToRemove);
				}
			}

			function setValue(newValue) {
				const newNumber = parseInt(newValue, 10);

				if (newNumber === currentValue && newNumber !== 0) return;

				// Always show at least one digit (for zero)
				const reversedNumberString = String(newNumber).padStart(1, '0').split('').reverse().join('');

				// Handle adding or removing digits
				if (reversedNumberString.length > digits.length) {
					generateDigits(reversedNumberString.length - digits.length);
				} else if (reversedNumberString.length < digits.length) {
					removeExtraDigits(reversedNumberString.length);
				}

				digits.forEach((digit, index) => {
					const num = reversedNumberString[index] || '0';
					if (digit.isNew) {
						// Start new digit at 0 and animate to target
						digit.style.marginTop = '0em';
						void digit.offsetHeight; // Trigger reflow
						digit.style.marginTop = `-${num}em`;
						digit.isNew = false; // Mark as initialized
					} else {
						digit.style.marginTop = `-${num}em`;
					}
				});

				currentValue = newNumber;
			}

			// Initialize with current value
			const initialValue = parseInt(element.getAttribute('data-value'), 10) || 0;
			setValue(initialValue);

			return { setValue };
		}

		function updateScoreboard(data) {
			// Update scores with animation
			const homeScore = parseInt(data.home_score, 10);
			const guestScore = parseInt(data.guest_score, 10);

			if (homeScore !== lastHomeScore) {
				homeScoreTicker.setValue(homeScore);
				lastHomeScore = homeScore;
			}

			if (guestScore !== lastGuestScore) {
				guestScoreTicker.setValue(guestScore);
				lastGuestScore = guestScore;
			}

			// Update sets won with animation
			const homeSets = parseInt(data.home_sets_won, 10) || 0;
			const guestSets = parseInt(data.guest_sets_won, 10) || 0;
			if (homeSets !== lastHomeSets) {
				homeSetTicker.setValue(homeSets);
				lastHomeSets = homeSets;
			}
			if (guestSets !== lastGuestSets) {
				guestSetTicker.setValue(guestSets);
				lastGuestSets = guestSets;
			}

			/* document.getElementById('home-sets-won').textContent = data.home_sets_won;
			document.getElementById('guest-sets-won').textContent = data.guest_sets_won; */

			// Update period, make sure UPPERCASE is used for period_desc
			const getOrdinalSuffix = (num) => {
				if (num >= 11 && num <= 13) return 'TH';
				switch (num % 10) {
					case 1: return 'ST';
					case 2: return 'ND';
					case 3: return 'RD';
					default: return 'TH';
				}
			};

			document.getElementById('period').textContent = data.period_desc.toUpperCase();
			if (data.period_desc === "Intermission" || data.period_desc === "Pregame"){
				document.getElementById('period').textContent = data.clock;
			}

			// Update timeouts with animation
			const homeTimeouts = parseInt(data.home_timeouts, 10) || 0;
			const guestTimeouts = parseInt(data.guest_timeouts, 10) || 0;

			updateTeamTimeouts('home', homeTimeouts);
			updateTeamTimeouts('guest', guestTimeouts);

			lastHomeTimeouts = homeTimeouts;
			lastGuestTimeouts = guestTimeouts;

			// Update timeout animation
			updateTimeoutAnimation(data.timeout_clock);

			 // Update home and guest team stats with durations
			const homeStats = data.home_stats;
			const guestStats = data.guest_stats;
			const homeStatsDuration = data.home_stats_duration;
			const guestStatsDuration = data.guest_stats_duration;
			const homeNewAnimation = data.home_new_animation;
			const guestNewAnimation = data.guest_new_animation;

			document.getElementById('home-stats-text').innerHTML = homeStats;  // Using innerHTML to support HTML formatting
			document.getElementById('guest-stats-text').innerHTML = guestStats;

			if (homeNewAnimation) {
				updateStatsAnimation(homeStatsAnimation, homeStats, homeStatsDuration, true)
			}
			if (guestNewAnimation) {
				updateStatsAnimation(guestStatsAnimation, guestStats, guestStatsDuration, false)
			}
		}

		function fetchData() {
			fetch('http://localhost:5000/data')
				.then(response => response.json())
				.then(data => {
					updateScoreboard(data);
				})
				.catch(error => console.error('Error fetching data:', error));
		}

		// Update every 50ms
		setInterval(fetchData, 50);
	</script>
</body>

</html>